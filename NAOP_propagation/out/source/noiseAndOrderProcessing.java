/* autogenerated by Processing revision 1289 on 2023-02-09 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import peasy.*;
import processing.serial.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class noiseAndOrderProcessing extends PApplet {


int networkSize = 12; // number of ball

String debug =""; 

// MANAGE PERSPECTIVE

PeasyCam cam;

// MANAGE ARDUINO && TENNSY

Serial DueSerialNativeUSBport101; // The native serial port of the DUE fibish with 101
Serial teensyport;

// change these for screen size
float fov = 45;  // degrees
float w = 1000;
float h = 800;

// don't change these
float cameraZ, zNear, zFar;
float w2 = w / 2;
float h2 = h / 2;



int nbBall = 12;  // number of ball in function drawBall
int nbMaxDelais= 1000; // delais de suivi entre chaque ball (en frame)



float netPhase [] =  new float  [networkSize];

//float [][] phases = new float[nbBall][nbMaxDelais];  // phase  à suivre le numero de la balle et le temps de decalage du suivi

int [] revLfo = new int [networkSize];

int numberOfStep = 6400; // 6400 step to do a round

int [] oldPositionToMotor  = new int [networkSize];
int [] positionToMotor  = new int [networkSize];

int [] DataToDueCircularVirtualPosition = new int [networkSize];  // position à envoyer à la la carte Teensy pour controler les moteurs


BallManager ballManager = new BallManager();

public void settings() {
  size(600, 600, P3D);

  ballManager.init();
}

public void setup(){
  //***************************************** SET 3D CAM 
  cam = new PeasyCam(this, 2000);
  cameraZ = (h / 2.0f) / tan(radians(fov) / 2.0f);
  zNear = cameraZ / 10.0f;
  zFar = cameraZ * 10.0f;
  println("CamZ: " + cameraZ);
  rectMode(CENTER);
  
  frameRate(5); //30
  
  //  teensyport = new Serial(this,Serial.list()[1],115200); // "/dev/cu.usbmodem142401" GOOD
  int recordingTimeSec= 3; // nombre de secondes d'enregistrement
   contextG = new ContextG(recordingTimeSec);
   samplerG = new SamplerG();

}

public void draw() { 
  //  println(frameCount + ": " + ( debug ));
  background(0);
  
  translate(width/2, -height/2, 1000);// To set the center of the perspective
  
  //****** LES FONCTIONS DE SAMPLING DE GUILLAUME****
   contextG.checkIfSamplingNeedToStopS();
   contextG.display();
   contextG.computeSeconds(); 
   //displayMouseAndRecordSampleOrDrawSample();
  //******
  
  
  if(contextG.recording && false == contextG.doneRecording) 
  { 
    circle( mouseX, mouseY, 10 );
    samplerG.addSample( mouseX, mouseY );
  }
  else 
  {
    if(samplerG.fullTime() > 0)
    {
        //samplerG.drawRecordingWithVertexes();        
        PVector position = samplerG.getCurrentPosition();
        samplerG.draw(position);
        
        ballManager.update(position);
    }
  }
  

  rotate(-HALF_PI ); //TO change the beginning of the 0 (cercle trigo) and the cohesion point to - HALF_PI 
     

/*
    
    // note pour moi!! ATTENTION à rechanger la ligne de dessous 
    // **** for (int i = 2; i <  networkSize-2; i+=1)
  for (int i = 0; i <  networkSize; i+=1)
  { // la premiere celle du fond i=2,  la derniere celle du devant i=11
    oldPositionToMotor[i]=positionToMotor[i];

  if (phases[i][frameCount % nbMaxDelais]>0) 
  {    
    positionToMotor[i]= ((int) map (phases[i][frameCount % nbMaxDelais], 0, TWO_PI, 0, numberOfStep)); //
  }   
  else 
  {
   positionToMotor[i]= ((int) map (phases[i][frameCount % nbMaxDelais], 0, -TWO_PI, numberOfStep,  0)); //
  } 
    
  if (oldPositionToMotor[i]> positionToMotor[i]) //fonction de comptage du nombre de tour. Elle fonctionne seulement de gauche à droite
        {
    revLfo[i]++; // ajoute 1 au compteur quand l'ancienne position > actuelle position   
    }
  } 
  int i = 0;  // imprime les données de la balle samplée uniquement toutes les 10 frames
  if (frameCount%3==0){ //
   print ( " phase "  + phases[i][frameCount % nbMaxDelais] );
  println ( " compteur "  + revLfo[i] +  " position " +  positionToMotor[i] + " temps écoulé " + millis()%1000);  
   }
     assignMotorWithPosition();   //fonction qui calcule et envoye les donnes de position à la carte de controle des moteurs
}

*/






class Ball{
  
  
}
class BallManager{
  
  int nbBalls;
  int nbMaxDelais;

  float [][] phases;    // phase  à suivre le numero de la balle et le temps de decalage du suivi


  BallManager(int nbBalls, int nbMaxDelais)
  {
    this.nbBalls = nbBalls;
    this.nbMaxDelais = nbMaxDelais;
    this.phases = = new float[nbBall][nbMaxDelais];
  }

  public void init(){

    //Initialisation des boules 
    // la première boule à une phase
    // une phase c'est un endroit sur le cercle en radiant
    // les boules qui suivent leur phase est composé d'un temps et d'un espace/écart  
    for (int i = 0; i < this.nbBalls; i++) {
    for (int j = 0; j < this.nbMaxDelais; j++)
      phases[i][j] = PI; // on met un écart de 0 ou PI (c'est la même chose)
    }
  }

  public void update(PVector position){

    float netPhase11 = =  map (position.x, 0, 300, 0, TWO_PI); 

    this.phases[0][frameCount % nbMaxDelais] = netPhase11; // assigne à la phase et à "chaque frame" la phase samplée. nbMaxDelais n'est pas utilisée 
    
    this.drawBall(0, phases[0][frameCount % nbMaxDelais] );

    for (int i = 1; i < this.nbBalls; i++) 
    {
        // la boutle 0 n'est pas affichée
        //la boule 1 suit la boule 0 avec 1 frame d'écart 
        
       this.follow( i-1, i, 1 * i, 0);  // Modifier les deux derniers paramètres : délais et phase . 
        // Ici le premier parametre 1*i decale dans le TEMPS le suivi des balles avec un delai d'une frame * i par rapport à la phase samplée : phases[0][frameCount % nbMaxDelais]
        // Le deuxieme parametrere est l'ecart dans l'ESPACE de phase entre chaque balle. 0, il n'y a pas d'ecart, 1, il y a un ecart de phase. à experimenter!
        this.drawBall(i, phases[i][frameCount % nbMaxDelais] );
        
    }  
  }

  // display ball on screen
  public void drawBall(int n, float phase) 
  { 
        pushMatrix();
        translate(-w2, -h2, -1000);
        noStroke();
        float side = height*0.15f*1/nbBall;
        float rayon = width/2; 
        float x = rayon*cos(phase);
        float y = rayon*sin(phase);
        translate (x, y, 200+(50*5*n));  
        colorMode(RGB, 255, 255, 255);
        fill( 0, 255, 0 ); 
        sphere(side*3);
        popMatrix();
    }

    // fonction de suivi par rapport à la balle target dont le mouvement est samplé.. 
    public void follow( int target, int follower, int delais, float deltaphase) 
    { 
        // Pour nous la target est la netphase11 dont le mouvement est samplé. 
        int step = frameCount % nbMaxDelais;
        int followedStep = (step + nbMaxDelais - delais) % nbMaxDelais;
        phases[follower][step] = this.diffAngle(phases[target][followedStep] + deltaphase, 0);
    }
  
  // return the difference angle1 - angle2 between two angle between -PI PI
  public float diffAngle(float angle1, float angle2)
   { 
        float result = angle1 - angle2;
        while (result > PI) {
            result -= 2 * PI;
        }
        while (result < -PI) {
            result += 2 * PI;
        }
        return result;
    }
}
class ContextG
{
    int actualSec,lastSec, secondsSinceRecordingStart, measureToStartRecording;
    boolean recording = false;
    boolean doneRecording = false;
    int currentTime;
    int secondsToRecord; //nb seconds during which we are going to record

    String infoText;

    ContextG(int secs)
    {
      this.secondsToRecord = secs; 
      this.reset();
    }
    
    
    public void startRecording()
    {
      // start recording and reset the measure counter to 0
       this.recording = true;  
       this.secondsSinceRecordingStart=0;
    }
    
    
    public void reset()
    {
       fill(255);
       this.infoText = "...waiting";
       this.recording = false;
       this.doneRecording = false;
       this.actualSec=0;
       this.lastSec=0;
       this.secondsSinceRecordingStart =0;                 
       this.measureToStartRecording=0;
       this.currentTime=0;     
    }
  
    public void computeSeconds()
    {
       this.currentTime = millis();// Get the current time in milliseconds
       int seconds = (this.currentTime / 1000) % 60; // number of seconds that have passed  since the program started running
       this.actualSec = seconds;
    }
    
    
   public void display()
   {     
     this.displayTimer();
     displayText(this.infoText);
   }
    
    
   /**
      Increment the measure
      Display the timer (seconds since recording started) when recording
    */
    public void displayTimer()
    {
       if  (this.actualSec!= this.lastSec)
       {      
           this.lastSec = this.actualSec;     
           
           if(this.recording && false == this.doneRecording)
           {
              this.secondsSinceRecordingStart++;
              displayValue(this.secondsSinceRecordingStart);
           }       
       }
    }

  
    /**
      Check when to stop the recording based on the number of seconds to record and the recording state
      If we need to stop we call the sampler and ask it to begingPlaying
    */
    public void checkIfSamplingNeedToStopS() 
    {
         if (this.recording &&  (this.secondsSinceRecordingStart >= this.secondsToRecord) ) 
         {
            this.recording = false;
            this.doneRecording=true;
            this.infoText = "done recording";
            samplerG.completeSampling();
        }
    }

}
void debugSampler(SamplerG sampler)
{
    //sampler.addInterpolationSamplePoints();
    displaySamplePoints(sampler);
}

void displaySamplePoints(SamplerG sampler){
  
  
  int lastMsTime = 0;
  
   for( int i=1; i< sampler.samples.size(); i++) 
   {
        GSample s = sampler.samples.get(i);
        
        int diff = s.msTime - lastMsTime;
        lastMsTime = s.msTime;
        
        //println ("diff ", diff);
        
        fill(255);
        
        if(s.isInterpolation){
           fill(0xFFFF8C00);
        }
        
       circle( s.position.x, s.position.y, 20 );        
    }
}

/*
    If we are recording and not done with it, we display the mouse position with a circle
    If we are done recording we call the sampler and tell him to display the next point (unless it has no points)
*/
void displayMouseAndRecordSampleOrDrawSample()
{
  
}


int clickCounter = 0;


void mousePressed() 
{  
    clickCounter++;
      
    if(1 == clickCounter)
    {
       samplerG.reset();
       contextG.startRecording();
       contextG.infoText = "... recording";
    }
    
    else if (clickCounter>=2)
    {
      background( 0 );
      samplerG.reset();  
      contextG.reset();
      clickCounter = 0;
    }   
}
int secondsToRecord = 4;
// variables globales guillaume
ContextG contextG;
SamplerG samplerG;

//    dans le MAIN de Benamin
/*
public void settings() {
  size(600, 600, P3D);
  //windowRatio(600, 600);
} 
*/
//
/*
void setup()  // 
{ // j'ai copié ton setup dans le mien, dans l'onglet Main Benjamin Light
   frameRate( 10 );
   int recordingTimeSec= 2; // nombre de secondes d'enregistrement
   contextG = new ContextG(recordingTimeSec);
   samplerG = new SamplerG();
}

*/
/*
void draw() 

{
    background(0);
    contextG.checkIfSamplingNeedToStopS();
    contextG.display();
    contextG.computeSeconds(); 
    displayMouseAndRecordSampleOrDrawSample(); 
}
*/


class GSample
{
  int msTime;       //ms time since recording start
  PVector position; //  x, y coordinates
 
  
  //debug variables
  int newMsTime;
  boolean isInterpolation = false;
  
  GSample(int msTime, PVector position, boolean isInterpolation) 
  {
    this.msTime = msTime;  
    this.position = position;  
    this.isInterpolation = isInterpolation;
    this.newMsTime = 0;
  }
}
class SamplerG {

  ArrayList<GSample> samples;
  
  int recordingStartTimeMs;
  int playbackFrame;   
  int initialFullTime;


  SamplerG() 
  {
    this.samples = new ArrayList<GSample>();
    recordingStartTimeMs = 0;
  }
  
  public void reset() 
  {
    this.samples = new ArrayList<GSample>();
    playbackFrame = 0;
  }
  
  public void addSample( int x, int y ) 
  { 
    int now = millis();
    
    if( this.samples.size() == 0 ){
      recordingStartTimeMs = now;
    }
    
    // milliseconds since recording start
    int msSinceStart = now - recordingStartTimeMs;
    
    // create new sample and add to array list
    this.samples.add( new GSample( msSinceStart, new PVector(x,y), false) );
  }
  
  /*
    Returns msTime of last sample point
  */
  public int fullTime() 
  {
    return ( this.samples.size() > 1 ) ?
    this.samples.get( this.samples.size()-1 ).msTime : 0;
  }
  
  public void infos()
  {
    println( "Number of samples : ", this.samples.size());
    println( "Full time : ", fullTime());
    
  }
  
  
  /*
    Start points replay
  */
  public void completeSampling() 
  {
    
    println("--- BEGING PLAYING ---");   
    
    recordingStartTimeMs = millis();
    
    playbackFrame = 0;  
    
    initialFullTime = fullTime();
    
    addInterpolationSamplePoints();
    //println( "with new samples : ", samples.size() );
    //reComputeTimestamps();
  }


   /*
   
   */
   public void reComputeTimestamps()
   {
     
     //fullTime();  initialFullTime
     long interval = (contextG.secondsToRecord * 1000) / samples.size();
     
      print("interval in ms", interval);
      
      int start = 0;
          
      for( int i=0; i< this.samples.size(); i++) {
               
       
        this.samples.get(i).newMsTime = PApplet.parseInt(start);
        //samples.get(i).msTime = int(start);
        
        start +=  interval;
         
        //println(i, samples.get(i).msTime,  samples.get(i).newMsTime);
      }
     
   }



  public void addInterpolationSamplePoints()
  {
    GSample s0 = this.samples.get(0);
    GSample s1 = this.samples.get(samples.size()-1);
    
    
    float distance = round(dist(s0.position.x, s0.position.y, s1.position.x, s1.position.y));
    
    
    //200 = 5
    // n = n*5/200
    contextG.infoText = "distance " + distance;
    
    
     // Set the number of interpolation sample points to add
    int numInterpolationPoints = round(distance * 5 / 200 );
    
    if(numInterpolationPoints <= 0) numInterpolationPoints = 2;
    
    println("distance = ", distance,  numInterpolationPoints);
    
    // Interpolate the x and y positions of the sample points
    float x0 = s0.position.x;
    float y0 = s0.position.y;
    float x1 = s1.position.x;
    float y1 = s1.position.y;
    int t0 = s0.msTime;
    int t1 = s1.msTime;
    
    int msTimeIncrement = (t1-t0) / numInterpolationPoints;
    int startMsTime = t0 + msTimeIncrement;
   

    // Calculate the weight factor increment for each interpolation point
    float weightFactorIncrement = 1.0f / (numInterpolationPoints + 1);


    // Add the interpolation sample points
    for(int j = 1; j <= numInterpolationPoints; j++) {
      // Calculate the weight factor for the current interpolation point
      float t = weightFactorIncrement * j;
  
      // Calculate the interpolated x and y positions
      float x = lerp(x0, x1, t);
      float y = lerp(y0, y1, t);
  
      // Draw a circle at the interpolated position
      //circle(x, y, 10);
      this.samples.add( new GSample(startMsTime, new PVector(x,y), true) );
      startMsTime = startMsTime+msTimeIncrement;
    }
  }


  /* 
      This code is responsible for drawing the recording as a series of connected lines, using the LINES style. 
      The beginShape() and endShape() functions define the beginning and end of a shape, 
      and the vertex() function adds a vertex to the shape at the specified position.
  */
  public void drawRecordingWithVertexes(){
    // set the stroke color
    //int c = color(random(255),random(255),random(255));
    stroke(255); //c

    // Begin a new shape in the LINES style
    beginShape(LINES);
    
     // Iterate through the samples list
    for( int i=1; i<samples.size(); i++) {
      // Add a vertex at the previous sample's x and y position
      vertex( this.samples.get(i-1).position.x, this.samples.get(i-1).position.y ); // replace vertex with Pvector ???
      // Add a vertex at the current sample's x and y position
      vertex( this.samples.get(i).position.x, this.samples.get(i).position.y );
    }
    
    // End the shape
    endShape();   
  }
  
  
  
  public PVector getCurrentPosition(){
    
    // Calculate the current time in milliseconds, modulo the full time of the recording
    int now = (millis() - recordingStartTimeMs) % fullTime();
    
     //println("now", now);
     
     
    // If the current time is less than the time of the current playback frame, reset the playback frame to 0
    if( now < samples.get( playbackFrame ).msTime ){
       playbackFrame = 0;
    }
        
    // While the time of the next frame is less than the current time, increment the playback frame
    while( this.samples.get( playbackFrame+1).msTime < now ) {
       playbackFrame = (playbackFrame+1) % (samples.size()-1);
    }
         
         
    // Get the current and next frames
    GSample s0 = this.samples.get( playbackFrame );
    GSample s1 = this.samples.get( playbackFrame+1 );
    
    // Calculate the time and position of the current and next frames
    float t0 = s0.msTime;
    float t1 = s1.msTime;
    float dt = (now - t0) / (t1 - t0);
    float x = lerp( s0.position.x, s1.position.x, dt );
    float y = lerp( s0.position.y, s1.position.y, dt );
    
    
     PVector position = new PVector(x, y);
    
    
    return position;
  }
  
  
  
  /* 
      This code is responsible for drawing the recording  in a loop. 
    
     The while loop is used to iterate through the samples list and find the current playback frame. 
     The lerp() function is used to interpolate the position of the current frame based on the time elapsed. 
     The interpolated position is then used to draw a circle at that position.
  */
  
  
  
  
  
  public void draw(PVector position) 
  {     
     int c = color(random(255),random(255),random(255));
     fill(c);
     
    // Draw a circle at the interpolated position
    circle( position.x, position.y, 20 );  
    
  }
}


void displayValue(int value){
   textSize (100);
   text (value, width - 100, 100);
}

void displayText(String text)
{
  if(null == text){
     return;
  }
  
   fill(255);
   textSize (20);
   text (text, width - 150, 600);
}

void assignMotorWithPosition() {
  
           for (int i = 0; i < 12; i++) {
      // rev[i]=rev[0];


      //*******************************  ASSIGN MOTOR WITH POSITION

      if (revLfo[i]!=0  && (positionToMotor[i] >  0) ) { // number of revLfoolution is even and rotation is clock wise   
        DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (positionToMotor[i], 0,numberOfStep, 0,numberOfStep))+ (revLfo[i]*numberOfStep);
      }

      if (revLfo[i]!=0  && (positionToMotor[i] <  0)) { // number of revLfoolution is even and rotation is Counter clock wise          // pos[i]= int (map (positionToMotor[i], 0, -NumberofStep, 0,numberOfStep))+ (revLfo[i]*NumberofStep);
        DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (positionToMotor[i], 0, -numberOfStep,numberOfStep, 0)) +(revLfo[i]*numberOfStep);       //   print ("pos "); print (i); print (" ");println (pos[i]);
      }

      if (revLfo[i]==0 && (positionToMotor[i] < 0) ) { //  number of revLfoolution is 0 and rotation is counter clock wise 
        DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (positionToMotor[i], 0, -numberOfStep,numberOfStep, 0));        
      }         
      if  (revLfo[i]==0 && (positionToMotor[i] > 0) ) {  //  number of revLfoolution is 0 and rotation is clock wise     
        DataToDueCircularVirtualPosition[i]= PApplet.parseInt (map (positionToMotor[i], 0,numberOfStep, 0,numberOfStep));                //      print ("pos "); print (i); print (" CW revLfo=0 ");println (pos[i]);
      }
      
  //    recordLastDataOfMotorPosition[i]=  DataToDueCircularVirtualPosition[i];
    }
  
  }
   
void dataToTeensy() {
    int speedDelta=10;
    int driverOnOff=3;
    int dataToTeensyNoJo=-3; // trig noJoe in Teensy
    String dataMarkedToTeensyNoJo  ="<" // BPM9   

      +   DataToDueCircularVirtualPosition[11]+ ","+DataToDueCircularVirtualPosition[10]+","+DataToDueCircularVirtualPosition[9]+","+DataToDueCircularVirtualPosition[8]+","+DataToDueCircularVirtualPosition[7]+","
      +   DataToDueCircularVirtualPosition[6]+  ","+DataToDueCircularVirtualPosition[5]+","+DataToDueCircularVirtualPosition[4]+","+DataToDueCircularVirtualPosition[3]+","+DataToDueCircularVirtualPosition[2]+","//DataToDueCircularVirtualPosition[2]

      +  (speedDelta) +","+ driverOnOff +","+dataToTeensyNoJo+","
      
  //    + TrigmodPos[11]+","+TrigmodPos[10]+","+TrigmodPos[9]+","+TrigmodPos[8]+","+TrigmodPos[7]+","+TrigmodPos[6]+","+TrigmodPos[5]+","+TrigmodPos[4]+","+TrigmodPos[3]+","+TrigmodPos[2]+","+TrigmodPos[1]+","+TrigmodPos[0]+ ">";  // to manage 12 note

    +0+","+0+","+0+","+0+","+0+","+0+","+0+","+0+","+0+","+0+","+0+">";    

    println(frameCount + ": " +  " addSignalDataMarkedToTeensyNoJo" + ( dataMarkedToTeensyNoJo ));
  //  DueSerialNativeUSBport101.write(dataMarkedToTeensyNoJo);// Send data to Arduino.
    teensyport.write(dataMarkedToTeensyNoJo); // Send data to Teensy. only the movement
 }


  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "noiseAndOrderProcessing" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
